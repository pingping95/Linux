#!/bin/bash

### BEGIN INFO
### Supported OS : CentOS 7
### Description  : Check EC2 Vulnarabilities
### END INFO



# Root 유저가 아닐 경우 실행 불가
if [ "$EUID" -ne 0 ]
    then echo "ROOT 권한으로 실행하여 주십시오."
    exit
fi


alias ls=ls


# File Name
DATE_STR=$(date +%m%d)
PRIVATE_IP=$(curl -s http://169.254.169.254/latest/meta-data/local-ipv4)

RESULT_FILE="${PRIVATE_IP}.txts"



echo > "$RESULT_FILE" 2>&1
echo "***************************************************************************"				>> "$RESULT_FILE" 2>&1
echo "*                                                                         *"				>>  "$RESULT_FILE" 2>&1
echo "*                      Linux Vulnerability Check                          *"				>>  "$RESULT_FILE" 2>&1
echo "*                      Version : 1.0                                      *"				>>  "$RESULT_FILE" 2>&1
echo "*                      Copyright : Bespinglobal                           *"				>>  "$RESULT_FILE" 2>&1
echo "*                                                                         *"				>>  "$RESULT_FILE" 2>&1
echo "***************************************************************************"				>>  "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1
echo ""
echo ""
echo "################## Linux 점검 스크립트를 실행합니다 ####################" >> "$RESULT_FILE" 2>&1
echo "Check Date : ${DATE_STR}" >> "$RESULT_FILE" 2>&1
echo ""
echo ""

echo "==============================  시스템  정보 ==============================" >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1

echo "1. 시스템 기본 정보" >> "$RESULT_FILE" 2>&1
echo "   운영체제	: $(head -n 1 /etc/system-release) " >> "$RESULT_FILE" 2>&1
echo "   호스트 이름	: $(uname -n) " >> "$RESULT_FILE" 2>&1
echo "   커널 버전	: $(uname -r) " >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1

echo "2. 네트워크 정보" >> "$RESULT_FILE" 2>&1
ifconfig -a >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1

echo "============================== 점검 결과 요약 ==============================" >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1
echo >> "$RESULT_FILE" 2>&1












# Define Functions
show_message() {
echo "" >> "$RESULT_FILE" 2>&1
echo "" >> "$RESULT_FILE" 2>&1
echo "----------------------------------------------------------------------------" >> "$RESULT_FILE" 2>&1
echo -e "$1 " >> "$RESULT_FILE" 2>&1
echo "----------------------------------------------------------------------------" >> "$RESULT_FILE" 2>&1
echo "" >> "$RESULT_FILE" 2>&1
}






######################################################################
######################################################################
######################################################################
show_message "[1] Password 관련 설정 확인 "
######################################################################
######################################################################
######################################################################



### 1.1
show_message "[1.1] /etc/passwd 파일의 사용자 UID와 GID 값인 세 번째, 네 번째 필드에서 root외 ‘O’값을 가진 사용자 계정이 존재하는지 확인
(root UID/GID 중복 점검) "

if [ "$(cat /etc/passwd | awk -F : '{print $1,$3}' | grep -E " 0" | grep -v root)" ]
	then
		echo " > [취약] root 이외에 UID가 '0'인 계정이 존재합니다" >> "$RESULT_FILE" 2>&1
	else
		echo " > [양호] root 이외에 UID가 '0'인 계정이 존재하지 않습니다" >> "$RESULT_FILE" 2>&1
fi




### 1.2
show_message "[1.2] 로그인이 필요하지 않은 계정에 대하여 /bin/false나 /sbin/nologin을 설정한다.
(/bin/false : 로그인만 허용. /sbin/nologin : 로그인 허용 안함)
(로그인 Shell 제한) "

# 1. Login이 필요하지 않은 계정들 파악
no_login_accounts=$(cat /etc/passwd | egrep "^daemon|^bin|^sys|^adm|^listen|^nobody|^nobody4|^noaccess|^diag|^listen|^operator|^games|^gopher" | grep -v "admin" | grep -v "systemd-network")

for account in $no_login_accounts
do
	account_name=$(echo "${account}" | awk -F : '{print $1}')
	if [[ "$account" == *"/sbin/nologin"* ]]
	then
		echo " > [양호] '$account_name' 계정은 /sbin/nologin으로 설정되어 있습니다. " >> "$RESULT_FILE" 2>&1

	elif [[ "$account" == *"/bin/false"* ]]
	then
		echo " > [양호] '$account_name' 계정은 /bin/false로 설정되어 있습니다. " >> "$RESULT_FILE" 2>&1

	else
		echo " > [취약] '$account_name' 계정은 /bin/false 혹은 /sbin/nologin이 되어 있지 않습니다. " >> "$RESULT_FILE" 2>&1
	fi
done



### 1.3
show_message "[1.3] john the ripper를 통한  /etc/shadow의 복사본을 점검한다. HAE의 자체적인 패스워드 정책에 따라서 패스워드를 생성한다.
(취약한 패스워드 점검) "

# /etc/shadow의 복사본 유무 점검

shadow_check=$(ls -l /etc/shadow* | grep -v "/etc/shadow$")

if [ -n "$shadow_check" ]
then
	echo " > [양호] /etc/shadow의 복사본이 존재합니다." >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /etc/shadow의 복사본이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi

## TODO
## HAE의 자체 패스워드 정책 확인 필요



### 1.4
show_message "[1.4] 침해사고시의 위험성을 대비하여 /etc/shadow파일을 생성하고 권한을 000으로 설정한다.
(패스워드 파일 권한 설정) "

# File 유무 확인
if [ "$(cat /etc/passwd | grep "root" | awk -F: '{print $2}' | sed -n '1p')" = x ]
	then
		# /etc/shadow 파일이 존재하며, 읽기 권한 부여
		if test -r /etc/shadow
			then
				# Shadow 파일 있음
				echo " > [양호] Shadow 패스워드를 사용중입니다" >> "$RESULT_FILE" 2>&1

				if [ "$(stat -c '%a' /etc/shadow)" -eq 0 ]
					then
						echo " > [양호] 권한 : $(ls -l /etc/shadow | awk '{print $1}') " >> "$RESULT_FILE" 2>&1
					else
						echo " > [취약] 권한 : $(ls -l /etc/shadow | awk '{print $1}') " >> "$RESULT_FILE" 2>&1
				fi

			else
				# Shadow 파일 없음
				echo " > [취약] Shadow 패스워드를 사용하지 않습니다" > "$RESULT_FILE" 2>&1
		fi
fi



### 1.5
show_message "[1.5] /etc/login.defs 파일 내 'PASS_MIN_LEN'을 8이상으로 설정한다.
(패스워드 최소 길이 설정) "

min_len=$(cat /etc/login.defs | grep PASS_MIN_LEN | awk '{print $2}' | sed '1d')

if [[ $min_len -ge 8 ]]
then
	echo " > [양호] PASS_MIN_LEN이 $min_len 글자입니다." >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] PASS_MIN_LEN이 $min_len 글자입니다." >> "$RESULT_FILE" 2>&1
fi


### 1.6
show_message "[1.6] /etc/pam.d/system-auth 파일 내 'retry minlen lcredit ucredit dcredit ocredit'를 설정한다.
[권고 사항] password requisite pam_cracklib.so retry=3 minlen=8 lcredit=0 ucredit=0 dcredit=-1 ocredit=-1
(패스워드 복잡도 설정) "

pem_crack=$(cat /etc/pam.d/system-auth | grep "pam_cracklib.so")

if [[ -n $pem_crack ]]
then
	echo " > [확인 필요] 권고값과 일치하는지 확인이 필요합니다. " >> "$RESULT_FILE" 2>&1
	echo " > $pem_crack " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] pam_cracklib.so 라인이 없습니다." >> "$RESULT_FILE" 2>&1
fi


### 1.7
show_message "[1.7] /etc/pam.d/system-auth 파일 중 no_magic_root : root, deny=4, lock_time : 120, no_magic_root reset 확인
(계정 잠금 임계값 설정)"

no_mg_root_check=$(cat /etc/pam.d/system-auth | grep "no_magic_root")

if [ -n "$no_mg_root_check" ]
then
	echo -e " > [확인 필요] no_magic_root가 포함된 구문이며, 권고값에 맞게 설정이 필요합니다.
'$no_mg_root_check' " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /etc/pam.d/system-auth 파일에 no_magic_root가 포함된 구문이 없습니다. " >> "$RESULT_FILE" 2>&1
fi





### 1.8
show_message "[1.8] /etc/login.defs 파일 내 PASS_MAX_DAYS 91 를 확인한다.
(패스워드 최대 사용기간 설정) "

pass_max_days=$(cat /etc/login.defs | grep PASS_MAX_DAYS | awk '{print $2}' | sed '1d')

if (( $pass_max_days == 91 ))
then
	echo " > [양호] PASS_MAX_DAYS가 $pass_max_days 일입니다." >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] PASS_MAX_DAYS가 $pass_max_days 일입니다. " >> "$RESULT_FILE" 2>&1
fi


### 1.9
show_message "[1.9] cat /etc/pam.d/system-auth 파일을 점검하여 설정값이 5이상이 되도록 설정한다.
[권고 사항] password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=5
(최근 패스워드 기억 설정) "


s_auth_remember=$(cat /etc/pam.d/system-auth | grep "remember")

if [[ -n $s_auth_remember ]]
then
	echo " > [확인 필요] 권고값과 일치하는지 확인이 필요합니다. " >> "$RESULT_FILE" 2>&1
	echo " > $s_auth_remember " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] remember 구문이 없습니다. " >> "$RESULT_FILE" 2>&1
fi




######################################################################
######################################################################
######################################################################
show_message "[2] 접근 제어 "
######################################################################
######################################################################
######################################################################

### 2.1
show_message "[2.1] /etc/xinetd.conf 의 권한이 644인 경우
(xinetd.conf 권한 설정) "

### TODO
### TODO


if [ -f /etc/xinetd.conf ]
then
	xinetd_perm=$(stat -c '%a' /etc/xinetd.conf )
	echo " > [확인 필요] /etc/xinetd.conf 파일이 존재하며 권한은 '$xinetd_perm' 입니다. " >> "$RESULT_FILE" 2>&1
	
else
	echo " > [확인 필요] /etc/xinetd.conf 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi




### 2.2
show_message "[2.2] su 명령어의 권한을 확인하고, 그룹 내의 사용 가능한 계정들을 확인하여 불필요한 계정의 존재시 삭제한다.
(SU 명령 제한) "

wheel_users=$(cat /etc/group | grep wheel | awk -F : '{print $4}')
su_pam_wheel_check=$(cat /etc/pam.d/su | grep "#auth" | grep required | grep pam_wheel.so)

# 허용된 계정만 su 명령어를 통해 계정 변경이 가능한지 확인
if [[ -n $su_pam_wheel_check ]]
then
	echo " > [취약] 해당 라인(pam_wheel.so)의 주석이 해제되어야 합니다. " >> "$RESULT_FILE" 2>&1
	echo " > $su_pam_wheel_check " >> "$RESULT_FILE" 2>&1
	echo "" >> "$RESULT_FILE" 2>&1
else
	echo " > [양호] 해당 라인의 주석(pam_wheel.so)이 설정되어 있습니다. " >> "$RESULT_FILE" 2>&1
	echo " > $su_pam_wheel_check " >> "$RESULT_FILE" 2>&1
	echo "" >> "$RESULT_FILE" 2>&1
fi

echo "" "$RESULT_FILE" 2>&1

echo -e " > [확인 필요] wheel 그룹 내 불필요한 계정이 있을 경우 삭제
wheel 그룹원 : $wheel_users " >> "$RESULT_FILE" 2>&1



### 2.3
show_message "[2.3] sshd데몬이 동작하는지 여부를 확인하여 동작가능 상태로 설정한다.
(암호화된 원격 접속 설정) "

ps -ef | grep "sshd" > temppp
grep -v "grep" temppp > SSHhhh

if [ "$(cat SSHhhh)" ]
then
	echo " > [양호] sshd 서비스 데몬이 동작 중입니다" >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] sshd 서비스 데몬이 동작 중이지 않습니다" >> "$RESULT_FILE" 2>&1
fi

rm -rf {temppp,SSHhhh}


### 2.4
show_message "[2.4] /etc/pam.d/login 파일 설정 중 ( auth required /lib/security/pam_securetty.so )항목을 확인하고 주석이 없는 상태가 맞는지 확인한다.
(원격 root접속 설정) "

if [ "$(grep pam_securetty.so /etc/pam.d/login | grep -v '#')" ]
then
	if [ "$(grep pts /etc/securetty | grep -v '#')" ]
	then
		echo " > [취약] root 원격 접속 제한 설정이 필요합니다" >> "$RESULT_FILE" 2>&1
	else
		echo " > [양호] root 원격 접속 제한 설정이 되어 있습니다" >> "$RESULT_FILE" 2>&1
	fi
else
	echo " > [취약] root 원격 접속 제한 설정이 필요합니다" >> "$RESULT_FILE" 2>&1
fi



show_message "[2.5]
ksh : # /etc/profile ( TMOUT=300 이나 export TMOUT )
csh : # /etc/csh.login 에서 set TMOUT=300 )
(타임 아웃 설정) "

tmo_count_1=$(grep -c TMOUT /etc/profile)
tmo_count_2=$(grep -c TMOUT /etc/csh.login)

if [ "$tmo_count_1" -gt 1 ]
then
	echo -e " > [양호] /etc/profile에 TMOUT이 설정되어 있습니다 (300이상으로 설정되어 있는지 확인)
	$(grep TMOUT /etc/profile) " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /etc/profile에 TMOUT이 설정되어 있지 않습니다" >> "$RESULT_FILE" 2>&1
fi

if [ "$tmo_count_2" -gt 1 ]
then
	echo -e " > [양호] /etc/csh.login에 TMOUT이 설정되어 있습니다 (300이상으로 설정되어 있는지 확인)
	$(grep TMOUT /etc/csh.login) " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /etc/csh.login에 TMOUT이 설정되어 있지 않습니다" >> "$RESULT_FILE" 2>&1
fi


######################################################################
######################################################################
######################################################################
show_message "[3] 시스템 보안 "
######################################################################
######################################################################
######################################################################


show_message "[3.1]
사용자의 기본 환경파일의 권한을 640이하로 설정한다.
( etc/profile, $HOME/.profile, $HOME/.login, $HOME/.cshrc, $HOME/.tcshrc, $HOME/.kshrc
$HOME/.bashrc, $HOME/.bash_profile, $HOME/.history, $HOME/.sh_history )
(환경 파일 권한 설정) "


# /etc/profile 체크
if [[ -f /etc/profile ]]
then
	perm=$(stat -c '%a' /etc/profile)
	if [ "$perm" -le 640 ]
	then
		echo " > [양호] /etc/profile의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
	else
		echo " > [취약] /etc/profile의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
	fi
else
	echo " > [취약] /etc/profile 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi
echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1


# ROOT 유저
echo " >>> ROOT  기본 환경파일 권한" >> "$RESULT_FILE" 2>&1

# File들을 Array로 생성
FILES=( "/root/.profile" "/root/.login" "/root/.cshrc" "/root/.tcshrc" "/root/.kshrc" "/root/.bashrc" "/root/.bash_profile" "/root/.history" "/root/.sh_history" )

# For문을 돌되, if문으로 해당 파일이 있을 경우에만 권한 확인
for FILE in "${FILES[@]}";
do
	if [[ -f "${FILE}" ]]
	then	
		perm=$(stat -c '%a' "$FILE")

		if [ "$perm" -le 640 ]
		then
			echo " > [양호] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
		fi

	else
		echo " > [없음] '${FILE}' 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
	fi
done
echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1


# ROOT 외의 모든 user들을 변수로 선언
users=$(grep "/bin/bash\|/bin/zsh\|/bin/csh" /etc/passwd | grep -v root | cut -d ':' -f1)

# ROOT 외의 모든 유저
for user in $users;
do
	echo " >>> $user 기본 환경파일 권한" >> "$RESULT_FILE" 2>&1
	# File들을 Array로 생성
	FILES=( "/home/$user/.profile" "/home/$user/.login" "/home/$user/.cshrc" "/home/$user/.tcshrc" "/home/$user/.kshrc" "/home/$user/.bashrc" "/home/$user/.bash_profile" "/home/$user/.history" "/home/$user/.sh_history" )

	# For문을 돌되, if문으로 해당 파일이 있을 경우에만 권한 확인
	for FILE in "${FILES[@]}";
	do
		if [[ -f "${FILE}" ]]
		then	
			perm=$(stat -c '%a' "$FILE")

			if [ "$perm" -le 640 ]
			then
				echo " > [양호] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
			else
				echo " > [취약] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
			fi

		else
			echo " > [없음] '${FILE}' 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
		fi
	done
	echo -e "----------------------------------------------------------------------------------------------
	" >> "$RESULT_FILE" 2>&1
done





show_message "[3.2]
wtmp/utmp/btmp/syslog/sulog/pacct/authlog/messages/loginlog/lastlog와 같은 주요 파일과
/etc, /.sbin, /usr과 같은 주요 디렉터리와에 일반사용자의 쓰기 권한이 설정되어 있는지 확인한다.
(주요 디렉터리 및 중요 파일의 권한 설정) "




show_message "[3.3]
/etc/hosts 설정 권한이 644이하이고, 소유주가 root 둘 다 만족하도록 설정한다.
(Host 파일 설정) "


ho_perm=$(stat -c '%a' /etc/hosts)
ho_group=$(stat -c '%G' /etc/hosts)
ho_user=$(stat -c '%U' /etc/hosts)

if [ "$ho_perm" -ge 644 ] && [ "$ho_group" = root ] && [ "$ho_user" = root ]
then
    echo " > [양호] /etc/hosts 설정 권한이 '$ho_perm'이며, 소유주가 그룹, 유저 모두 root입니다. " >> "$RESULT_FILE" 2>&1
else
    echo -e " > [취약] /etc/hosts 설정을 수정해야 합니다.
 > 권한 : '$ho_perm' 
 > 그룹 : '$ho_group' 
 > 유저 : '$ho_user' " >> "$RESULT_FILE" 2>&1
fi



show_message "[3.4]
# ls –alR /etc/rc* # ls –alR /sbin/rc* # ls –alR /etc/init* # ls –alR /sbin/init* 명령어를 사용하여 내용 확인하고,
부팅 스크립트파일(심볼릭 링크 제외)의 허가권을 754(rwxr-xr--)가 되도록 설정한다.
(부팅 스크립트 점검) "


# 1. /etc/rc*
etc_rc_files=$(find /etc/rc* -type f 2> /dev/null)

if [ -n "$etc_rc_files" ]
then
	for file in $etc_rc_files;
	do
		# 각 파일의 권한 체크
		perm=$(stat -c '%a' "$file")
		if [ "$perm" -eq 754 ]
		then
			echo " > [양호] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		fi
	done
else
    echo " > [없음] /etc/rc* 내에 스크립트 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi

echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1


# 2. /sbin/rc*
sbin_rc_files=$(find /sbin/rc* -type f 2> /dev/null)

if [ -n "$sbin_rc_files" ]
then
	for file in $sbin_rc_files;
	do
		# 각 파일의 권한 체크
		perm=$(stat -c '%a' "$file")
		if [ "$perm" -eq 754 ]
		then
			echo " > [양호] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		fi
	done
else
    echo " > [없음] /sbin/rc* 내에 스크립트 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi

echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1

# 3. /etc/init*
etc_init_files=$(find /etc/init* -type f 2> /dev/null)

if [ -n "$etc_init_files" ]
then
	for file in $etc_init_files;
	do
		# 각 파일의 권한 체크
		perm=$(stat -c '%a' "$file")
		if [ "$perm" -eq 754 ]
		then
			echo " > [양호] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		fi
	done
else
    echo " > [없음] /sbin/rc* 내에 스크립트 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi

echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1

# 4. /sbin/init*
sbin_init_files=$(find /sbin/init* -type f 2> /dev/null)

if [ -n "$sbin_init_files" ]
then
	for file in $sbin_init_files;
	do
		# 각 파일의 권한 체크
		perm=$(stat -c '%a' "$file")
		if [ "$perm" -eq 754 ]
		then
			echo " > [양호] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] $file 파일의 권한이 $perm 입니다. " >> "$RESULT_FILE" 2>&1
		fi
	done
else
    echo " > [없음] /sbin/rc* 내에 스크립트 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi

echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1



show_message "[3.5]
root 계정의 환경 변수 설정 파일(.profile, .cshrc등)과 /etc/profile 등에서 PATH 환경 변수에 포함되어 있는 . 을 제거한다. (# env 또는 # echo $PATH)
(PATH 설정) "

# File들을 Array로 생성
FILES=( "/root/.profile" "/root/.cshrc" "/root/.tcshrc" "/root/.kshrc" "/root/.bashrc" "/root/.bash_profile" "/etc/profile" )

# For문을 돌되, if문으로 해당 파일이 있을 경우에만 권한 확인
for FILE in "${FILES[@]}";
do
	if [[ -e "${FILE}" ]]
	then
		check_dot=$(grep 'PATH=' "$FILE" | grep '\.')
		if [ -n "$check_dot" ]
			then
				echo " > [취약] '$FILE' 파일의 PATH 환경변수에 .이 포함되어 있습니다" >> "$RESULT_FILE" 2>&1
			else
				echo " > [양호] '$FILE' 파일의 PATH 환경변수에 .이 포함되어 있지 않습니다" >> "$RESULT_FILE" 2>&1
		fi
	else
		echo " > [없음] '${FILE}' 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
	fi
done





show_message "[3.6]
umask 명령어를 사용하여 현재 설정된 UMASK 값이 022인지 점검하고 022, 027이 아닌 경우 변경한다. (#umask)
(UMASK 설정) "

if [ "$(umask)" -eq 0022 ] || [ "$(umask)" -eq 0027 ]
then
	echo " > [양호] UMASK 값이 022 or 027로 설정되어 있습니다. " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] UMASK 값이 022 or 027로 설정되어 있지 않습니다. " >> "$RESULT_FILE" 2>&1
fi


show_message "[3.7]
# find / -user root -type f \( -perm -4000 -o -perm -2000 \) 또는 # find / -user root -type f -perm +6000 -ls
해당 명령어를 통해 주기적으로 SUID/SGID가 설정된 파일을 점검한다.
(SUID/SGID의 설정) "

echo -e " [출력] find / -user root -type f \( -perm -4000 -o -perm -2000 \)
 >
$(find / -user root -type f \( -perm -4000 -o -perm -2000 \) -exec ls -al {} \; 2> /dev/null)
 
 [출력] find / -user root -type f -perm +6000 -ls
 >
$(find / -user root -type f -perm +6000 -exec ls -al {} \; 2> /dev/null)
" >> "$RESULT_FILE" 2>&1



show_message "[3.8]
ls –l [홈 디렉터리 경로]를 통해 쓰기 권한이 부여되어 있는지 확인하고 권한 설정이 755인지 확인한다.
(홈디렉터리 권한 설정) "

homedir_perm=$(stat -c '%a' /home/)

if [ "$homedir_perm" -eq 755 ]
then
	echo " > [양호] /home/의 권한이 755입니다. " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /home/의 권한이 755가 아닙니다. " >> "$RESULT_FILE" 2>&1
fi



show_message "[3.9]
history file( $HOME/.history … $HOME/.sh_history … $HOME/.bash_history )의 접근권한을
해당 home directory 소유자로, 타사용자의 읽기 및 쓰기 권한을 해제 한다. (600 권고)
(history file 권한 설정) "


# ROOT 유저
echo " >>> ROOT 히스토리 파일 권한 " >> "$RESULT_FILE" 2>&1

# File들을 Array로 생성
FILES=( "/root/.bash_history" "/root/.history" "/root/.sh_history" )

# For문을 돌되, if문으로 해당 파일이 있을 경우에만 권한 확인
for FILE in "${FILES[@]}";
do
	if [[ -f "${FILE}" ]]
	then	
		perm=$(stat -c '%a' "$FILE")

		if [ "$perm" -eq 600 ]
		then
			echo " > [양호] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
		else
			echo " > [취약] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
		fi

	else
		echo " > [없음] '${FILE}' 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
	fi
done
echo -e "----------------------------------------------------------------------------------------------
" >> "$RESULT_FILE" 2>&1


# ROOT 외의 모든 user들을 변수로 선언
users=$(grep "/bin/bash\|/bin/zsh\|/bin/csh" /etc/passwd | grep -v root | cut -d ':' -f1)

# ROOT 외의 모든 유저
for user in $users;
do
	echo " >>> $user 기본 환경파일 권한" >> "$RESULT_FILE" 2>&1
	# File들을 Array로 생성
	FILES=( "/home/$user/.bash_history" "/home/$user/.history" "/home/$user/.sh_history" )

	# For문을 돌되, if문으로 해당 파일이 있을 경우에만 권한 확인
	for FILE in "${FILES[@]}";
	do
		if [[ -f "${FILE}" ]]
		then	
			perm=$(stat -c '%a' "$FILE")

			if [ "$perm" -eq 600 ]
			then
				echo " > [양호] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
			else
				echo " > [취약] '${FILE}'의 권한이 '${perm}'입니다." >> "$RESULT_FILE" 2>&1
			fi

		else
			echo " > [없음] '${FILE}' 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
		fi
	done
	echo -e "----------------------------------------------------------------------------------------------
	" >> "$RESULT_FILE" 2>&1
done


show_message "[3.10]
# find / -nouser –exec ls –al {} \; #find / -nogroup –exec ls –al {} \; #find /dev –type f –exec ls –al {} \;
소유자나 그룹이 없는 파일이 존재하지 않는지 확인한다.
(/dev에 존재하지 않는 device 파일 점검) "

# /dev
if [ "$(find /dev -type f -xdev -ls 2>/dev/null)" ]
	then
		echo " > [취약] /dev에 파일이 존재합니다" >> "$RESULT_FILE" 2>&1
  else
		echo " > [양호] /dev에 파일이 존재하지 않습니다" >> "$RESULT_FILE" 2>&1
fi


# user, group
if [ "$(find / \( -nouser -o -nogroup \) -xdev -ls 2>/dev/null)" ]
	then
		echo " > [취약] 소유자가 존재하지 않는 파일 및 디렉터리가 존재합니다" >> "$RESULT_FILE" 2>&1
  else
		echo " > [양호] 소유자가 존재하지 않는 파일 및 디렉터리가 존재하지 않습니다" >> "$RESULT_FILE" 2>&1
fi


######################################################################
######################################################################
######################################################################
show_message "[4] 서비스 보안 "
######################################################################
######################################################################
######################################################################



show_message "[4.1]
/etc/inetd.conf파일에서 r-command 서비스 (rsh, rlogin, rexec), RPC 서비스 (sadmind, rquotad, rpc.rusersd, rpc.sprayd, rpc.rwalld,
rpc.rstatd, rpc.rexd, rpc.ttdbserverd,  rpc.cmsd, kcms_server, rpc.nids, rpc.ypupdated, cachefsd, rpc.pcnfsd),
기타 불필요한 서비스 (ftp, talk, uucp, finger, time, echo, discard, daytime, chargen, dtspcd, printer, tftp, dmi, sendmail 등)를 점검한다.
(불필요한 서비스 중지) "

### TODO
### TODO


show_message "[4.2]
NFS서비스를 사용하지 않는 경우 : NFS데몬(nfsd, statd, mountd)를 kill
사용해야 하는 경우 (/etc/export)
공유된 파일 시스템은 필요에 의해 읽기/쓰기 권한이 통제된 시스템에 대해서만 접근 가능하도록 설정한다. (Rw모드를 Ro모드로 변환)
NFS exported 파일에 꼭 필요한 공유 디렉터리만 나열하고, everyone으로 시스템이 마운트 되어있는지, 관련 보안패치가 수행되었는지 여부를 확인한다.
(NFS 공유 설정) "

# NFS 서비스 활성화 유무
nfs_enabled=$(systemctl is-enabled nfs 2> /dev/null)

if [[ "enabled" == "$nfs_enabled" ]]
	then
		echo " > [취약] NFS 서비스 관련 데몬이 활성화되어 있습니다 " >> "$RESULT_FILE" 2>&1

		# /etc/export 내용 출력
		echo " > [확인 필요] /etc/export 파일 내용 출력 " >> "$RESULT_FILE" 2>&1
		echo "cat /etc/export 2> /dev/null " >> "$RESULT_FILE" 2>&1

elif [[ "disabled" == "$nfs_enabled" ]]
	then
		echo " > [양호] NFS 서비스 관련 데몬이 비활성화되어 있습니다" >> "$RESULT_FILE" 2>&1
else
	echo " > [양호] NFS 서비스가 설치되어 있지 않습니다" >> "$RESULT_FILE" 2>&1
fi




show_message "[4.3]
ftp를 사용하지 않거나 /etc/passwd 에서 ftp 계정이 삭제되어 있는지 확인한다.
(FTP 서비스 설정) "

# FTP 서비스 유무 확인
ps -ef | grep "ftp" >> temp
grep -v "grep" temp >> FTP

if [ "$(cat FTP)" ]
	then
		echo " > [취약] ftp 서비스 데몬이 동작 중입니다" >> "$RESULT_FILE" 2>&1
  else
		echo " > [양호] ftp 서비스 데몬이 동작 중이지 않습니다" >> "$RESULT_FILE" 2>&1
fi

rm -rf ./FTP ./temp

# FTP User가 /etc/passwd에 있는지 확인
ftp_account=$(cat /etc/passwd | grep ftp 2>/dev/null)

if [ "$ftp_account" ]
	then
		echo " > [취약] ftp 계정이 존재합니다." >> "$RESULT_FILE" 2>&1
	else
		echo " > [양호] ftp 계정이 존재하지 않습니다" >> "$RESULT_FILE" 2>&1
fi



show_message "[4.4]
● Telnet
# vi /etc/issue(issue.net) (issue(issue.net) 파일이 존재 하지 않을 시 시스템 OS정보가 노출됨)  시스템 정보를 삭제한다.
● FTP
# /etc/vsftpd/vsftpd.conf 파일의 'ftpd_banner=' 설정의 주석을 제거하고,  '경고 메시지' 설정(없을 경우 추가)한다.
(서비스 배너 점검) "

# 1. Telnet

echo -e " > [확인 필요] /etc/issue 파일 출력 결과
$(cat /etc/issue) " >> "$RESULT_FILE" 2>&1	

echo " " >> "$RESULT_FILE" 2>&1

# 2. FTP

if [[ -f /etc/vsftpd/vsftpd.conf ]]
then
	ftpd_banner=$(cat /etc/vsftpd/vsftpd.conf | grep ftpd_banner)
	echo -e " > [확인 필요] ftpd_banner= 설정의 주석을 제거하고, 경고 메시지를 설정해야 합니다.
 > 출력 : '$ftpd_banner' " >> "$RESULT_FILE" 2>&1
else
	echo " > [양호] /etc/vsftpd/vsftpd.conf 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1	
fi



show_message "[4.5]
SNMP가 동작중일 경우 snmpd.conf 파일에서 community name을 기본값인 public이 아닌
추측 불가능한 다른 이름으로 변경하거나 값을 삭제하고, 필요 없을 경우 SNMP를 동작하지 않도록 설정한다.
(SNMP community string 값 설정) "

# SNMP 서비스 데몬 확인
ps -ef | grep "snmp" >> temp
grep -v "grep" temp >> SNMP

if [ "$(cat SNMP)" ]
	then
		snmp_com_check=$(cat /etc/snmp/snmpd.conf | grep "^com2sec" | grep public)
		if [ -n "$snmp_com_check" ]
		# Community name이 기본값일 경우
		then
			echo " > [취약] SNMP 서비스 데몬이 동작 중이며 community name이 public입니다." >> "$RESULT_FILE" 2>&1
		# Community name이 기본값이 아닐 경우
		else
			echo " > [양호] SNMP 서비스 데몬이 동작 중이지만 community name이 public이 아닙니다." >> "$RESULT_FILE" 2>&1
		fi
  	else
		echo " > [양호] SNMP 서비스 데몬이 동작 중이지 않습니다" >> "$RESULT_FILE" 2>&1
fi

rm -rf temp SNMP





show_message "[4.6]
1. 메일 서비스가 필요한 서버를 제외하고 SMTP 서비스를 사용하지 않도록 하고
2. chkconfig –list 결과를 확인하여 sendmail 서비스가 off 되어있는지 확인한다.
3. /etc/mail/sendmail.cf 파일에 NOVRFY, NOEXPN 명령을 삽입한다.
(SMTP 보안 설정) "

s_mail_check=$(ps -ef | grep sendmail | grep -v "grep")

if [ -n "$s_mail_check" ]
then
	s_mail_opt_check=$(cat /etc/mail/sendmail.cf | grep noexpn | grep novrfy)
	# noexpn, novtfy 옵션 설정
	if [ -n "$s_mail_opt_check" ]
	then
		echo " > [양호] SNMP 서비스 데몬이 동작 중이지만 NOVRFY, NOEXPN 명령이 삽입되었습니다." >> "$RESULT_FILE" 2>&1
	else
		echo " > [취약] SNMP 서비스 데몬이 동작 중이며 NOVRFY, NOEXPN 명령이 미삽입 상태입니다." >> "$RESULT_FILE" 2>&1
	fi
	# noexpn, novtfy 옵션 미설정
else
	echo " > [양호] SNMP 서비스 데몬이 동작 중이지 않습니다." >> "$RESULT_FILE" 2>&1
fi




show_message "[4.7]
서비스가 불필요한 경우 in.named데몬을 kill 한다.
DNS 서비스를 사용할 경우
< BIND8 DNS 설정(named.conf) 수정 예 >
options {
            allow-transfer { 존 파일 전송을 허용하고자 하는 IP;};
};
< BIND4.9 DNS 설정(named.boot) 수정 예 >
options
 xfrnets 허용하고자 하는 IP
를 통하여 BIND DNS를 설정하도록 한다.
(DNS 보안 설정) "

# Named 서비스 확인
ps -ef | grep "named" >> temp
grep -v "grep" temp >> DNS

if [ "$(cat DNS)" ]
	then
		echo " > DNS 서비스 데몬이 동작 중입니다 (버전 확인 필요)" >> "$RESULT_FILE" 2>&1
		echo " > named -v = $(named -v 2>/dev/null)"   >> "$RESULT_FILE" 2>&1
		echo ".......................  named.conf 파일 설정 값 확인  ..........................." >> "$RESULT_FILE" 2>&1
		echo " > grep allow-transfer /etc/named.conf = $(grep allow-transfer /etc/named.conf 2>/dev/null)"   >> "$RESULT_FILE" 2>&1
		echo " > grep xfrnets /etc/named.conf = $(grep xfrnets /etc/named.conf 2>/dev/null)"   >> "$RESULT_FILE" 2>&1
  else
		echo " > [양호] DNS 서비스 데몬이 동작 중이지 않습니다" >> "$RESULT_FILE" 2>&1
fi

rm -rf ./DNS ./temp



show_message "[4.8]
/etc/xinetd.conf 파일에 swat 항목이 없는지 확인하고, 있을 경우 주석처리 한다.
(SWAT 강제 공격 방지 설정) "

if [ -f /etc/xinetd.conf ]
then
	# swat 항목 체크
	swat_check=$(bash -c "cat /etc/xinetd.conf | grep swat" 2> /dev/null)
	if [ -n "$swat_check" ]
	then
		echo -e " > [확인 필요] /etc/xinetd.conf 파일 내에 swat 항목
$'swat_check' " >> "$RESULT_FILE" 2>&1
	else
		echo " > [양호] /etc/xinetd.conf 파일 내에 swat 항목이 없습니다. " >> "$RESULT_FILE" 2>&1
	fi
else
	echo " > [양호] /etc/xinetd.conf 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi



show_message "[4.9]
samba(smb)서비스를 중지한다.
(Samba 기능 제한 설정) "

# SNMP 서비스 데몬 확인
ps -ef | grep "smb" >> temp
grep -v "grep" temp >> SMB

if [ "$(cat SMB)" ]
	then
		echo " > [취약] SMB 서비스 데몬이 동작 중입니다" >> "$RESULT_FILE" 2>&1
  else
		echo " > [양호] SMB 서비스 데몬이 동작 중이지 않습니다" >> "$RESULT_FILE" 2>&1
fi

rm -rf temp SMB




######################################################################
######################################################################
######################################################################
show_message "[5] 모니터링 "
######################################################################
######################################################################
######################################################################

show_message "[5.1]
/etc/rsyslog.conf 파일에 권고설정이 적용되어 있는지 확인한다.
mail.debug     /var/log/maillog
*.info             /var/log/messages
*.alert            /var/log/messages
*.alert            /dev/console
*.alert            root
*.emerg         *
(로그기록 설정) "

# 1. mail.debug
mail_debug=$(cat /etc/rsyslog.conf | grep "mail\.debug")
if [[ -n "$mail_debug" ]]
then
	echo -e " > [확인 필요] mail.debug
'$mail_debug' " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] mail.debug 라인이 없습니다." >> "$RESULT_FILE" 2>&1
fi


# 2. *.info
asta_info=$(cat /etc/rsyslog.conf | grep "\*\.info")
if [[ -n "$asta_info" ]]
then
	echo -e " > [확인 필요] *.info
'$asta_info' " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] *.info 라인이 없습니다." >> "$RESULT_FILE" 2>&1
fi


# 3. *.alert
asta_alert=$(cat /etc/rsyslog.conf | grep "\*\.alert")
if [[ -n "$asta_alert" ]]
then
	echo -e " > [확인 필요] *.alert
'$asta_alert' " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] *.alert 라인이 없습니다." >> "$RESULT_FILE" 2>&1
fi


# 4. *.emerg
asta_emerg=$(cat /etc/rsyslog.conf | grep "\*\.emert")
if [[ -n "$asta_emerg" ]]
then
	echo -e " > [확인 필요] *.emerg
'$asta_emerg' " >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] *.emerg 라인이 없습니다." >> "$RESULT_FILE" 2>&1
fi



show_message "[5.2]
#tail -fn 50 /var/log/sulog #tail -fn 50 /var/log/secure 를 통하여 sulog가 기록되고 있는지 확인하고,
/etc/syslog.conf 파일에서 ( authpriv.*     /var/log/secure => 주석(#) 제거 )권고내용이 설정되어있는지 확인한다.
(SU 로그 설정) "

if [[ $(tail -n 50 /var/log/sulog 2> /dev/null) ]] || [[ $(tail -n 50 /var/log/secure 2> /dev/null) ]]
# sulog 기록 파일 존재
then
	# 권고 내용 설정 확인
	authpriv_check=$(grep "^authpriv\.\*" /etc/rsyslog.conf | grep /var/log/secure)
	
	if [ -n "$authpriv_check" ]
		# 설정되어 있는 경우 => 양호
		then
			echo " > [양호] sulog가 기록되고 있으며, 권고 내용이 설정되어 있습니다." >> "$RESULT_FILE" 2>&1
		# 설정되어 있지 않는 경우 => 취약
		else
			echo " > [취약] sulog가 기록되고 있지만, 권고 내용이 설정되어 있지 않습니다." >> "$RESULT_FILE" 2>&1
	fi
# sulog 기록 파일 미 존재 => 취약
else
	echo " > [취약] sulog가 관련 파일(sulog, secure) 2개 모두 없습니다. " >> "$RESULT_FILE" 2>&1
fi



show_message "[5.3]
#/var/log/lastlog #/var/run/lastlog 파일을 확인하여 lastlog가 존재하는지 확인하고, #last 를 통해 정상적으로 기록되고 있는지 확인한다.
(Lastlog 파일 관리) "


# 1. /var/log/lastlog
if [[ -e /var/log/lastlog ]] || [[ -e /var/run/lastlog ]]
then
	echo " > [양호] /var/log/lastlog 또는 /var/run/lastlog 파일이 존재합니다." >> "$RESULT_FILE" 2>&1
else
	echo " > [취약] /var/log/lastlog , /var/run/lastlog 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi

echo "----------------------------------------------------------------------------------------------" >> "$RESULT_FILE" 2>&1
# 3. last
	echo -e " > [출력] last 명령어 출력 결과 (최근 10개 기록)
$(last | head -n 10 2> /dev/null) " >> "$RESULT_FILE" 2>&1



######################################################################
######################################################################
######################################################################
show_message "[6] 기타 보안관리 "
######################################################################
######################################################################
######################################################################



show_message "[6.1]
1. Telnet : /etc/issue 를 열어 수정 #vi /etc/issue ( Warning!! Authorized users only. All activity may be monitored and reported. )
2. FTP : ftp 사용시 ftp banner 수정 #vi /etc/banners/ftp.msg ( Warning!! Authorized users only. All activity may be monitored and reported. )
vsftp사용시 #vi /etc/vsftpd/vsftpd.conf ( Ftpd_banner=< Warning!! Authorized users only. All activity may be monitored and reported. )
3. SSH # /etc/ssh/sshd_config ( Banner /etc/issue (주석 처리되어 있을 경우 주석 제거) )
(경고 메시지 설정) "

# issue.net : ssh 접속 후 패스워드 입력 전에 띄워주는 배너
# issue     : 원격 접속이 아닌 콘솔을 통해 로그인할 경우 보여주는 배너

# 1. Telnet
if [ -e /etc/issue ]
	then
		echo -e " > [확인 필요] /etc/issue 파일 내에 경고 메세지가 제대로 설정되어 있지 않을 경우 적절히 수정해야 합니다.
$(cat /etc/issue) " >> "$RESULT_FILE" 2>&1
	else
		echo " > [취약] /etc/issue 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi


# 2. FTP
if [ -e /etc/banners/ftp.msg ]
	then
		echo -e " > [확인 필요] /etc/banners/ftp.msg 파일 내에 경고 메세지가 제대로 설정되어 있지 않을 경우 적절히 수정해야 합니다.
$(cat /etc/banners/ftp.msg | grep -i warning) " >> "$RESULT_FILE" 2>&1
	else
		echo " > [없음] /etc/banners/ftp.msg 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi


# 3. vsftp
if [ -e /etc/vsftpd/vsftpd.conf ]
	then
		echo -e " > [확인 필요] /etc/vsftpd/vsftpd.conf 파일 내에 경고 메세지가 제대로 설정되어 있지 않을 경우 적절히 수정해야 합니다.
$(cat /etc/vsftpd/vsftpd.conf | grep -i warning) " >> "$RESULT_FILE" 2>&1
	else
		echo " > [없음] /etc/vsftpd/vsftpd.conf 파일이 존재하지 않습니다." >> "$RESULT_FILE" 2>&1
fi

# 4. SSH
if [ -e /etc/ssh/sshd_config ]
	then
		echo -e " > [확인 필요] /etc/ssh/sshd_config 파일 내에 경고 메세지가 제대로 설정되어 있지 않을 경우 적절히 수정해야 합니다.
$(cat /etc/ssh/sshd_config | grep Banner) " >> "$RESULT_FILE" 2>&1
fi





show_message "[6.2]
# cat /.exrc | grep ! 를 이용하여 불법적인 명령어의 존재여부를 확인한다. ( .exrc 파일이 없거나 .exrc 파일에 !로 시작하는 불법적인 명령어가 없도록 설정 )
(exrc 파일 설정) "

if [ -f /.exrc ]
then
	exrc_check=$(cat /.exrc | grep "\!")
	if [ -n "$exrc_check" ]
	then
		echo " > [취약] /.exrc 파일이 있으며 !로 시작하는 구문이 있습니다. " >> "$RESULT_FILE" 2>&1
	else
		echo " > [취약] /.exrc 파일이 있으나 !로 시작하는 구문은 없습니다. " >> "$RESULT_FILE" 2>&1
	fi
else
	echo " > [양호] /.exrc 파일이 없습니다. " >> "$RESULT_FILE" 2>&1
fi


show_message "[6.3]
현재 계정의 주기적 수행 스케줄 ( #crontab -l ) 일회성 수행 스케줄 ( #at -l )
각 계정별 자동 스케쥴 내역
주기적 수행 스케쥴 내역 ( #cat /var/spool/cron/crontabs/계정명 ) 일회성으로 수행되는 스케쥴 내역 ( #cat var/spool/cron/atjobs/계정명 ) 들을 확인한다.
(스케줄링 설정) "

# Crontab
crond_check=$(ps -ef | grep crond | grep -v "grep")
if [ -n "$crond_check" ]
then
	if [ -n "$(find /var/spool/cron/ -type f)" ]
		# cron 스케줄 내역이 있을 경우
		then
			find /var/spool/cron/ -type f | while read LINE;
			do
				echo -e " > [확인] $LINE 파일 출력 결과
$(cat $LINE) " >> "$RESULT_FILE" 2>&1
sleep 1
			done
		# cron 스케줄 내역이 없을 경우
		else
			echo " [없음] Crond 데몬이 있지만 각 계정별 주기적 수행 스케줄이 없습니다. " >> "$RESULT_FILE" 2>&1
	fi


else
	# crond 데몬 없을 경우
	echo " [없음] Crond 데몬이 없습니다. " >> "$RESULT_FILE" 2>&1
fi

echo " " >> "$RESULT_FILE" 2>&1
# at
atd_check=$(ps -ef | grep atd | grep -v "grep")
if [ -n "$atd_check" ]
then
	# atd 데몬 없을 경우
	echo " > [있음] atd 데몬이 있습니다. 각 계정별 일회성 수행 스케줄 확인 필요 " >> "$RESULT_FILE" 2>&1
else
	# atd 데몬 없을 경우
	echo " > [없음] atd 데몬이 없습니다. " >> "$RESULT_FILE" 2>&1
fi



show_message "[6.4]
#rpm -qa  | cut -f2 -d' ' 등의 명령어로 패치 내용을 확인한다.
(패치 확인) "

		echo -e " > [패치 내용 확인] rpm -qa | cut -f2 -d' '
$(rpm -qa | cut -f2 -d' ') " >> "$RESULT_FILE" 2>&1